<html><head><META http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>OQL to SQL translator</title><link rel="stylesheet" href="default.css"></head><body bgcolor="#ffffff" link="#6763a9" vlink="#6763a9" topmargin="0" bottommargin="0" leftmargin="0" marginheight="0" marginwidth="0"><a name="top"></a><table border="0" cellpadding="0" cellspacing="0" height="400"><tr><td width="10" valign="top" align="left" bgcolor="#7270c2"><img src="images/dotTrans.gif" width="1" height="1" border="0"></td><td valign="top" align="left" bgcolor="#7270c2" width="150"><img src="images/dotTrans.gif" width="1" height="1" border="0"></td><td width="7" valign="top" align="left"><img src="images/dotTrans.gif" border="0" width="1" height="1"></td><td width="70" valign="top" align="left"><img src="images/dotTrans.gif" width="70" height="6" border="0"></td><td width="100%" valign="top" align="left"><img src="images/top_2.gif" width="100%" height="6" border="0"></td></tr><tr><td width="10" bgcolor="#7270c2" valign="top" align="left"><img src="images/dotTrans.gif" border="0" width="1" height="1"></td><td bgcolor="#7270c2" valign="top" align="left" width="150"><img src="images/dotTrans.gif" border="0" width="1" height="1"></td><td width="7" bgcolor="#ffffff" valign="top" align="left"></td><td width="70" valign="top" align="left"><img src="images/dotTrans.gif" width="1" height="1" border="0"></td><td width="100%" valign="middle" align="left"><a href="license.html"><span class="menuTopOff">License</span></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://www.codehaus.org"><span class="menuTopOff">Codehaus</span></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://openejb.org"><span class="menuTopOff">OpenEJB</span></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://openjms.sf.net"><span class="menuTopOff">OpenJMS</span></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://openorb.sf.net"><span class="menuTopOn">OpenORB</span></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://tyrex.sf.net"><span class="menuTopOff">Tyrex</span></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br><img src="images/dotTrans.gif" width="1" height="2" border="0"></td></tr><tr><td width="10" bgcolor="#7270c2" valign="top" align="left"><img src="images/dotTrans.gif" width="10" height="3" border="0"></td><td bgcolor="#7270c2" valign="top" align="right" width="150"><img src="images/line_sm.gif" width="105" height="3" border="0"></td><td width="7" bgcolor="#a9a5de" valign="top" align="left"><img src="images/line_sm.gif" width="7" height="3" border="0"></td><td width="70" valign="top" align="left"><img src="images/line_light.gif" width="70" height="3" border="0"></td><td width="100%" valign="top" align="left"><img src="images/line_light.gif" width="100%" height="3" border="0"></td></tr><tr><td bgcolor="#7270c2" valign="top" align="left"><img src="images/dotTrans.gif" width="10" height="10" border="0"></td><td bgcolor="#7270c2" valign="top" align="left" width="150"><img src="images/dotTrans.gif" width="1" height="2" border="0"><br><table border="0" cellpadding="10" cellspacing="0"><tr><td><script type="text/javascript" src="http://www.ohloh.net/p/3635/widgets/project_users_logo.js"></script></td></tr></table><table border="0" cellpadding="0" cellspacing="0"><tr><td valign="top" align="left"><span class="subMenuOn">Old releases</span></td></tr><tr><td valign="top" align="left">
        &nbsp;
                <a href="releases-old.html"><span class="subMenuOff">General</span></a></td></tr><tr><td valign="top" align="left">
        &nbsp;
                <a href="http://www.castor.org/1.3/index.html"><span class="subMenuOff">Release 1.3</span></a></td></tr><tr><td valign="top" align="left">
        &nbsp;
                <a href="http://www.castor.org/1.3rc1/index.html"><span class="subMenuOff">Release 1.3rc1</span></a></td></tr><tr><td valign="top" align="left">
        &nbsp;
                <a href="http://www.castor.org/1.2/index.html"><span class="subMenuOff">Release 1.2</span></a></td></tr></table><br><table border="0" cellpadding="0" cellspacing="0"><tr><td valign="top" align="left"><span class="subMenuOn">Main</span></td></tr><tr><td valign="top" align="left">
        &nbsp;
                <a href="index.html"><span class="subMenuOff">Home</span></a></td></tr><tr><td valign="top" align="left">
        &nbsp;
                <a href="about.html"><span class="subMenuOff">About</span></a></td></tr><tr><td valign="top" align="left">
        &nbsp;
                <a href="features.html"><span class="subMenuOff">Features</span></a></td></tr><tr><td valign="top" align="left">
        &nbsp;
                <a href="download.html"><span class="subMenuOff">Download</span></a></td></tr><tr><td valign="top" align="left">
        &nbsp;
                <a href="dependencies.html"><span class="subMenuOff">Dependencies</span></a></td></tr><tr><td valign="top" align="left">
        &nbsp;
                <a href="reference-guide.html"><span class="subMenuOffHighlighted">Reference guide</span></a></td></tr><tr><td valign="top" align="left">
        &nbsp;
                <a href="presentations.html"><span class="subMenuOff">Publications</span></a></td></tr><tr><td valign="top" align="left">
        &nbsp;
                <a href="javadoc/overview-summary.html"><span class="subMenuOff">JavaDoc</span></a></td></tr><tr><td valign="top" align="left">
        &nbsp;
                <a href="maven-integration.html"><span class="subMenuOff">Maven 2 support</span></a></td></tr><tr><td valign="top" align="left">
        &nbsp;
                <a href="maven-archetypes.html"><span class="subMenuOff">Maven 2 archetypes</span></a></td></tr><tr><td valign="top" align="left">
        &nbsp;
                <a href="schema.html"><span class="subMenuOff">DTD &amp; Schemas</span></a></td></tr><tr><td valign="top" align="left">
        &nbsp;
                <a href="changes.html"><span class="subMenuOff">Recent HTML changes</span></a></td></tr><tr><td valign="top" align="left">
        &nbsp;
                <a href="news.html"><span class="subMenuOff">News Archive</span></a></td></tr><tr><td valign="top" align="left">
        &nbsp;
                <a href="http://castor.codehaus.org/rss/castor-announce.xml"><span class="subMenuOff">RSS news feed</span></a></td></tr><tr><td valign="top" align="left">
        &nbsp;
                <a href="http://docs.codehaus.org/display/CASTOR/"><span class="subMenuOffHighlighted">Project Wiki</span></a></td></tr></table><br><table border="0" cellpadding="0" cellspacing="0"><tr><td valign="top" align="left"><span class="subMenuOn">Development/Support</span></td></tr><tr><td valign="top" align="left">
        &nbsp;
                <a href="lists.html"><span class="subMenuOff">Mailing Lists</span></a></td></tr><tr><td valign="top" align="left">
        &nbsp;
                <a href="scm.html"><span class="subMenuOff">SVN/JIRA</span></a></td></tr><tr><td valign="top" align="left">
        &nbsp;
                <a href="contributing.html"><span class="subMenuOff">Contributing</span></a></td></tr><tr><td valign="top" align="left">
        &nbsp;
                <a href="support.html"><span class="subMenuOff">Support</span></a></td></tr><tr><td valign="top" align="left">
        &nbsp;
                <a href="http://bamboo.ci.codehaus.org/browse/CASTOR"><span class="subMenuOff">Continuous builds</span></a></td></tr><tr><td valign="top" align="left">
        &nbsp;
                <a href="professional-services.html"><span class="subMenuOffHighlighted">Prof. services</span></a></td></tr></table><br><table border="0" cellpadding="0" cellspacing="0"><tr><td valign="top" align="left"><span class="subMenuOn">Related projects</span></td></tr><tr><td valign="top" align="left">
        &nbsp;
                <a href="spring-orm-integration.html"><span class="subMenuOff">Spring ORM support</span></a></td></tr><tr><td valign="top" align="left">
        &nbsp;
                <a href="spring-xml-intro.html"><span class="subMenuOff">Spring XML factories</span></a></td></tr><tr><td valign="top" align="left">
        &nbsp;
                <a href="ws-integration.html"><span class="subMenuOff">WS frameworks</span></a></td></tr></table><br><table border="0" cellpadding="0" cellspacing="0"><tr><td valign="top" align="left"><span class="subMenuOn">XML</span></td></tr><tr><td valign="top" align="left">
        &nbsp;
                <a href="xml-link.html"><span class="subMenuOff">XML</span></a></td></tr></table><br><table border="0" cellpadding="0" cellspacing="0"><tr><td valign="top" align="left"><span class="subMenuOn">XML Code Generator</span></td></tr><tr><td valign="top" align="left">
        &nbsp;
                <a href="srcgen-link.html"><span class="subMenuOff">XML Code Generator</span></a></td></tr></table><br><table border="0" cellpadding="0" cellspacing="0"><tr><td valign="top" align="left"><span class="subMenuOn">JDO</span></td></tr><tr><td valign="top" align="left">
        &nbsp;
                <a href="jdo-introduction.html"><span class="subMenuOff">Introduction</span></a></td></tr><tr><td valign="top" align="left">
        &nbsp;
                <a href="jdo-starter-tutorial.html"><span class="subMenuOff">First steps</span></a></td></tr><tr><td valign="top" align="left">
        &nbsp;
                <a href="jdo.html"><span class="subMenuOff">Using JDO</span></a></td></tr><tr><td valign="top" align="left">
        &nbsp;
                <a href="jdo-database-conf.html"><span class="subMenuOff">JDO Config</span></a></td></tr><tr><td valign="top" align="left">
        &nbsp;
                <a href="types.html"><span class="subMenuOff">Types</span></a></td></tr><tr><td valign="top" align="left">
        &nbsp;
                <a href="jdo-mapping.html"><span class="subMenuOff">JDO Mapping</span></a></td></tr><tr><td valign="top" align="left">
        &nbsp;
                <a href="jdo-faq.html"><span class="subMenuOff">JDO FAQ</span></a></td></tr><tr><td valign="top" align="left">
        &nbsp;
                <a href="jdo-examples.html"><span class="subMenuOff">JDO Examples</span></a></td></tr><tr><td valign="top" align="left">
        &nbsp;
                <a href="jdo-howto.html"><span class="subMenuOffHighlighted">JDO HOW-TOs</span></a></td></tr><tr><td valign="top" align="left">
        &nbsp;
                <a href="jdo-tips-tricks.html"><span class="subMenuOffHighlighted">Tips &amp; Tricks</span></a></td></tr><tr><td valign="top" align="left">
        &nbsp;
                <a href="jdo-other-features.html"><span class="subMenuOff">Other Features</span></a></td></tr><tr><td valign="top" align="left">
        &nbsp;
                <a href="jdo-self-executable-examples.html"><span class="subMenuOff">JDO sample JAR</span></a></td></tr></table><br><table border="0" cellpadding="0" cellspacing="0"><tr><td valign="top" align="left"><span class="subMenuOn">Tools</span></td></tr><tr><td valign="top" align="left">
        &nbsp;
                <a href="schemaGen-anttask.html"><span class="subMenuOff">Schema generator</span></a></td></tr></table><br><table border="0" cellpadding="0" cellspacing="0"><tr><td valign="top" align="left"><span class="subMenuOn">Advanced JDO</span></td></tr><tr><td valign="top" align="left">
        &nbsp;
                <a href="jdo-caching-detail.html"><span class="subMenuOff">Caching</span></a></td></tr><tr><td valign="top" align="left">
        &nbsp;
                <a href="oql.html"><span class="subMenuOff">OQL</span></a></td></tr><tr><td valign="top" align="left">
        &nbsp;
                <a href="locking.html"><span class="subMenuOff">Trans. &amp; Locks</span></a></td></tr><tr><td valign="top" align="left">
        &nbsp;
                <a href="design-persist.html"><span class="subMenuOff">Design</span></a></td></tr><tr><td valign="top" align="left">
        &nbsp;
                <a href="key-generator.html"><span class="subMenuOff">KeyGen</span></a></td></tr><tr><td valign="top" align="left">
        &nbsp;
                <a href="long-transact.html"><span class="subMenuOff">Long Trans.</span></a></td></tr><tr><td valign="top" align="left">
        &nbsp;
                <a href="nested-attr.html"><span class="subMenuOff">Nested Attrs.</span></a></td></tr><tr><td valign="top" align="left">
        &nbsp;
                <a href="jdo-pooling.html"><span class="subMenuOff">Pooling Examples</span></a></td></tr><tr><td valign="top" align="left">
        &nbsp;
                <a href="postgresql-blobs.html"><span class="subMenuOff">LOBs</span></a></td></tr><tr><td valign="top" align="left">
        &nbsp;
                <a href="jdo-best-practice.html"><span class="subMenuOff">Best practice</span></a></td></tr></table><br><table border="0" cellpadding="0" cellspacing="0"><tr><td valign="top" align="left"><span class="subMenuOn">DDL Generator</span></td></tr><tr><td valign="top" align="left">
        &nbsp;
                <a href="ddlgen.html"><span class="subMenuOff">Using DDL Generator</span></a></td></tr><tr><td valign="top" align="left">
        &nbsp;
                <a href="ddlgen-properties.html"><span class="subMenuOff">Properties</span></a></td></tr><tr><td valign="top" align="left">
        &nbsp;
                <a href="ddlgen-anttask.html"><span class="subMenuOff">Ant task</span></a></td></tr><tr><td valign="top" align="left">
        &nbsp;
                <a href="ddlgen-mapping.html"><span class="subMenuOff">Type Mapping</span></a></td></tr></table><br><table border="0" cellpadding="0" cellspacing="0"><tr><td valign="top" align="left"><span class="subMenuOn">More</span></td></tr><tr><td valign="top" align="left">
        &nbsp;
                <a href="examples.html"><span class="subMenuOff">The Examples</span></a></td></tr><tr><td valign="top" align="left">
        &nbsp;
                <a href="extras.html"><span class="subMenuOff">3rd Party Tools</span></a></td></tr><tr><td valign="top" align="left">
        &nbsp;
                <a href="test-framework.html"><span class="subMenuOff">JDO Tests</span></a></td></tr><tr><td valign="top" align="left">
        &nbsp;
                <a href="ctf.html"><span class="subMenuOff">XML Tests</span></a></td></tr><tr><td valign="top" align="left">
        &nbsp;
                <a href="conf-lib.html"><span class="subMenuOff">Configuration</span></a></td></tr><tr><td valign="top" align="left">
        &nbsp;
                <a href=""><span class="subMenuOff"></span></a></td></tr><tr><td valign="top" align="left">
        &nbsp;
                <a href="http://www.java.net/"><span class="subMenuOff"><img src="images/javanet_button_90.gif" border="0"></span></a></td></tr></table><br><table border="0" cellpadding="0" cellspacing="0"><tr><td valign="top" align="left"><span class="subMenuOn">About</span></td></tr><tr><td valign="top" align="left">
        &nbsp;
                <a href="license.html"><span class="subMenuOff">License</span></a></td></tr><tr><td valign="top" align="left">
        &nbsp;
                <a href="user-experience.html"><span class="subMenuOffHighlighted">User stories</span></a></td></tr><tr><td valign="top" align="left">
        &nbsp;
                <a href="contributors.html"><span class="subMenuOff">Contributors</span></a></td></tr><tr><td valign="top" align="left">
        &nbsp;
                <a href="marketplace.html"><span class="subMenuOff">Marketplace</span></a></td></tr><tr><td valign="top" align="left">
        &nbsp;
                <a href="status.html"><span class="subMenuOff">Status, Todo</span></a></td></tr><tr><td valign="top" align="left">
        &nbsp;
                <a href="release-notes.html"><span class="subMenuOff">Changelog</span></a></td></tr><tr><td valign="top" align="left">
        &nbsp;
                <a href="library.html"><span class="subMenuOff">Library</span></a></td></tr><tr><td valign="top" align="left">
        &nbsp;
                <a href="contacts.html"><span class="subMenuOff">Contact</span></a></td></tr><tr><td valign="top" align="left">
        &nbsp;
                <a href="origins.html"><span class="subMenuOff">Project Name</span></a></td></tr></table><br></td><td width="7" bgcolor="#a9a5de" valign="top" align="left">&nbsp;</td><td width="70" valign="top" align="left">&nbsp;</td><td rowspan="4" width="100%" valign="top"><table cols="2" rows="2" border="0" cellpadding="0" cellspacing="0" width="100%"><tr><td valign="top" align="left"><br><img border="0" height="34" hspace="0" src="images/castor.gif" vspace="0" width="115"><br><img border="0" height="10" hspace="0" src="images/dotTrans.gif"></td><td width="120" height="5" valign="top" align="right"></td></tr></table><p></p><p></p><br><h2 align="center">OQL to SQL translator</h2><p><span class="bodyGrey">
                Reference: <a href="javadoc/org/exolab/castor/jdo/oql/package-summary.html"><api package="org.exolab.castor.jdo.oql">The Java OQL to SQL translator</api></a></span></p><HR size="1"><span class="bodyGrey"><b><a href="#News">News</a></b><br></span><span class="bodyGrey"><b><a href="#Status">Status</a></b><br></span><span class="bodyGrey"><b><a href="#Introduction">Introduction</a></b><br></span><span class="bodyGrey"><b><a href="#Overview">Overview</a></b><br></span><span class="bodyGrey"><b><a href="#Syntax">Syntax</a></b><br></span><span class="bodyGrey"><b><a href="#Type-and-validity-checking">Type and validity checking</a></b><br></span><span class="bodyGrey"><b><a href="#SQL-Generation">SQL Generation</a></b><br></span><span class="bodyGrey"><b><a href="#OQL-FAQ">OQL FAQ</a></b><br></span><span class="bodyGrey"><b><a href="#Summary">Summary</a></b><br></span><span class="bodyGrey"><b><a href="#Examples">Examples</a></b><br></span><span class="bodyGrey"><a href="#Java-class-files">&nbsp;&nbsp;&nbsp;&nbsp;Java class files</a><br></span><span class="bodyGrey"><a href="#Limit-Clause">&nbsp;&nbsp;&nbsp;&nbsp;Limit Clause</a><br></span><HR size="1"><br><a name="News"><h2>News</h2></a>
            <p><span class="bodyGrey"><b>Release 0.9.6</b>:<br>
               <table border="0" cellpadding="2" cellspacing="2"><tr><td colspan="2" height="5"></td></tr><span class="bodyGrey">
                  <tr><td align="left" valign="top" width="10">-</td><td align="left" valign="top"><span class="bodyGrey">Added support for LIMIT clause for MS SQL Server.</span></td></tr>
                  <tr><td align="left" valign="top" width="10">-</td><td align="left" valign="top"><span class="bodyGrey">In the case a RDBMS does not support LIMIT/OFFSET clauses, a
                      SyntaxNotSupportedException is thrown.</span></td></tr>
                  <tr><td align="left" valign="top" width="10">-</td><td align="left" valign="top"><span class="bodyGrey">Added support for a limit clause and an offset clause. Currently, only
                      HSQL, mySQL and postgreSQL are supported.</span></td></tr>
                  <tr><td align="left" valign="top" width="10">-</td><td align="left" valign="top"><span class="bodyGrey">Added an <a href="#Examples">example section</a>.</span></td></tr>
               </span></table>
            </span></p>
        <a name="Status"><h2>Status</h2></a>
            <p><span class="bodyGrey">
                The Castor OQL implementation is currently in phase 3 of development. 
                <br><br>
                NOTE: This documentation is not yet finished</span></p>
        <a name="Introduction"><h2>Introduction</h2></a>
            <p><span class="bodyGrey">
                This document describes an OQL to SQL translator to be added to the
                Castor JDO Java object <a href="design-persist.html#Persistence-API">Persistence API</a>. The translator will accept OQL
                queries passed as strings, and generate a parse tree of the OQL. It will
                then traverse the tree creating the appropriate SQL. The user will then
                be able to bind parameters to parameterized queries. Type checking will
                be performed on the bound parameters. When the user executes the query,
                the system will submit the query to the SQL database, and then
                postprocess the SQL resultset to create the appropriate result as a Java
                Object or literal. The current
                <a href="javadoc/org/exolab/castor/mapping/package-summary.html"><api package="org.exolab.castor.mapping">mapping</api></a> and
                <a href="javadoc/org/exolab/castor/persist/package-summary.html"><api package="org.exolab.castor.persist">persistence</api></a>
                packages will be used for metadata and RDBMS communication.</span></p>
            <p><span class="bodyGrey">
                Four of the (now defunct) SourceXchange milestones for this project call for java
                source code. These milestones will be referred to here as phase 1, 2, 3,
                and 4. There are many possible OQL features that can be supported, but
                weren't discussed in the proposal or RFP. Many of these are probably
                unwanted. These additional features are specified as phase 5, which is
                out of the scope of this SourceXChange project.</span></p>
        <a name="Overview"><h2>Overview</h2></a>
            <p><span class="bodyGrey">
                The parser will construct a parse tree as output from an OQL query
                string given as input. The OQL syntax is a subset of the syntax
                described in the <a href="http://www.odmg.org/">ODMG 3.0</a> specification section 4.12, with some
                additional constructs. Following is a description of the supported OQL
                syntax, and its SQL equivalent.</span></p>


            <p><span class="bodyGrey">
                Certain features of OQL may not be directly translatable to SQL, but
                may still be supported, by post processing the query. For example, the
                <b>first()</b> and <b>last()</b> collection functions supported in OQL
                are not directly translatable to standard SQL, but a resultset can be
                post-processed to return the appropriate values. Features requiring
                post-processing of SQL resultsets will be documented as such
                below.</span></p>

            <p><span class="bodyGrey">
                Currently the OQLQuery checks for correct syntax at the same time as
                it does type checking and other types of error checking. The new code
                will involve a multiple pass strategy, with the following passes:
                <ol>
                    <li>
                        Parse the String query checking for syntax errors, and return
                        a parse tree.</li>

                    <li>
                        Traverse the parse tree checking for correct types, valid member
                        and method identifiers, and use of features which are unsupported.
                        This pass may also generate some data necessary for creating the SQL.</li>

                    <li>
                        Traverse the tree one final time, creating the equivalent SQL
                        statement to the OQL Query originally passed.</li></ol></span></p>
        <a name="Syntax"><h2>Syntax</h2></a>
            <p><span class="bodyGrey">
                This section describes the first pass which will be done by the
                parser. The parser will create a StringTokenizer like this:
                <span class="bodyGrey"><pre>
StringTokenizer tokenizer
    = new StringTokenizer(oql,
    "\n\r\t,.()[]+-*/&lt;&gt;=:|$", true);</pre></span>
                This will create a StringTokenizer with the delimiter
                characters listed in the second argument, and it will return delimeters
                as well as tokens. The parser will also create a Vector to be used as a
                token buffer. As tokens are returned from the StringTokenizer they will be
                added to the Vector. Older tokens will be removed from the Vector when
                it reaches a certain size. The Vector will also be modified when the
                StringTokenizer returns multi character operators as seperate tokens, for
                example the -&gt; method invocation operator.</span></p>

            <p><span class="bodyGrey">
                The parser will consume tokens from the StringTokenizer, generating a
                ParseTree. Each ParseTree node will have a nodeType corresponding to its
                symbol in the OQL syntax. After each node is created it will look at the
                next token and act acordingly, either modifying its properties (i.e.
                for DISTINCT property of selectExpr), creating a new child node or
                returning an error. If the error travels up to the root node of the
                ParseTree, there is a syntax error in the OQL submitted. At the end of this
                pass, the ParseTree will contain an apropriate representation of the query,
                which will be analyzed, and used to create SQL. Below is the modified
                EBNF which will be the Castor OQL syntax.</span></p>

            <p><span class="bodyGrey">
                <span class="bodyBlack"><pre>
query                   ::= selectExpr
                            | expr

selectExpr              ::= <B>select</B> [<B>distinct</B>] 
                            projectionAttributes
                            fromClause
                            [whereClause]
                            [groupClause]
                            [orderClause]
                            [limitClause [offsetClause]]

projectionAttributes    ::= projectionList
                          | *

projectionList          ::= projection {, projection }

projection              ::= field
                          | expr [<B>as</B> identifier]

fromClause              ::= <B>from</B> iteratorDef {, iteratorDef}

iteratorDef             ::= identifier [ [<B>as</B> ] identifier ]
                          | identifier <B>in</B> identifier

whereClause             ::= <B>where</B> expr

groupClause             ::= <B>group by</B> fieldList {havingClause}

havingClause            ::= <B>having</B> expr

orderClause             ::= <B>order by</B> sortCriteria

limitClause             ::= <B>limit </B> queryParam

offsetClause            ::= <b>offset</b> queryParam

sortCriteria            ::= sortCriterion {, sortCriterion }

sortCriterion           ::= expr [ (<B>asc</B> | <B>desc</B>) ]

expr                    ::= castExpr

castExpr                ::= orExpr
                            | <B>(</B> type <B>)</B> castExpr

orExpr                  ::= andExpr {<B>or</B> andExpr}

andExpr                 ::= quantifierExpr {<B>and</B> quantifierExpr}

quantifierExpr          ::= equalityExpr
                            | <B>for all</B> inClause <B>:</B> equalityExpr
                            | <B>exists</B> inClause <B>:</B> equalityExpr

inClause                ::= identifier <B>in</B> expr

equalityExpr            ::= relationalExpr
                            {(<B>=</B> | <B>!=</B>) 
                                [compositePredicate] relationalexpr }
                            | relationalExpr {<B>like</B> relationalExpr}

relationalExpr          ::= additiveExpr
                            {(<B>&lt;</B> | <B>&lt;=</B> 
                                | <B>&gt;</B> | <B>&gt;=</B> ) 
                                    [ compositePredicate ] additiveExpr }
                                | additiveExpr <B>between</B> 
                                    additiveExpr <B>and</B> additiveExpr

compositePredicate      ::= <B>some</B> | <B>any</B> | <B>all</B>

additiveExpr            ::= multiplicativeExpr
                                {<B>+</B> multiplicativeExpr}
                            | multiplicativeExpr
                                {<B>-</B> multiplicativeExpr}
                            | multiplicativeExpr
                                {<B>union</B> multiplicativeExpr}
                            | multiplicativeExpr
                                {<B>except</B> multiplicativeExpr}
                            | multiplicativeExpr
                                {<B>||</B> multiplicativeExpr}

multiplicativeExpr      ::= inExpr {<B>*</B> inExpr}
                            | inExpr {<B>/</B> inExpr}
                            | inExpr {<B>mod</B> inExpr}
                            | inExpr {<B>intersect</B> inExpr}

inExpr                  ::= unaryExpr {<B>in</B> unaryExpr}

unaryExpr               ::= <B>+</B> unaryExpr
                            | <B>-</B> unaryExpr
                            | <B>abs</B> unaryExpr
                            | <B>not</B> unaryExpr
                            | postfixExpr

postfixExpr             ::= primaryExpr{<B>[</B> index <B>]</B>}
                            | primaryExpr
                            {(<B>.</B> | <B>-&gt;</B>)identifier[arglist]}

index                   ::= expr {<B>,</B> expr}
                            | expr <B>:</B> expr

argList                 ::= <B>(</B>[ valueList ]<B>)</B>

primaryExpr             ::= conversionExpr
                            | collectionExpr
                            | aggregateExpr
                            | undefinedExpr
                            | collectionConstruction
                            | identifier[ arglist ]
                            | queryParam
                            | literal
                            | <B>(</B> query <B>)</B>

conversionExpr          ::= <B>listtoset(</B> query <B>)</B>
                            | <B>element(</B> query <B>)</B>
                            | <B>distinct(</B> query <B>)</B>
                            | <B>flatten(</B> query <B>)</B>

collectionExpr          ::= <B>first(</B> query <B>)</B>
                            | <B>last(</B> query <B>)</B>
                            | <B>unique(</B> query <B>)</B>
                            | <B>exists(</B> query <B>)</B>

aggregateExpr           ::= <B>sum(</B> query <B>)</B>
                            | <B>min(</B> query <B>)</B>
                            | <B>max(</B> query <B>)</B>
                            | <B>avg(</B> query <B>)</B>
                            | <B>count(</B>( query | * )<B>)</B>

undefinedExpr           ::= <B>is_undefined(</B> query <B>)</B>
                            | <B>is_defined(</B> query <B>)</B>

fieldList               ::= field {, field}

field                   ::= identifier<B>:</B> expr

collectionConstruction  ::= <B>array(</B>[valueList]<B>)</B>
                            | <B>set(</B>[valueList]<B>)</B>
                            | <B>bag(</B>[valueList]<B>)</B>
                            | <B>list(</B>[valueList]<B>)</B>
                            | <B>list(</B>listRange<B>)</B>

valueList               ::= expr {, expr}

listRange               ::= expr..expr

queryParam              ::= <B>$</B>[(type)]longLiteral

type                    ::= [<B>unsigned</B>] <B>short</B>
                            | [<B>unsigned</B>] <B>long</B>
                            | <B>long long</B>
                            | <B>float</B>
                            | <B>double</B>
                            | <B>char</B>
                            | <B>string</B>
                            | <B>boolean</B>
                            | <B>octet</B>
                            | <B>enum</B> [identifier.]identifier
                            | <B>date</B>
                            | <B>time</B>
                            | <B>interval</B>
                            | <B>timestamp</B>
                            | <B>set &lt;</B>type<B>&gt;</B>
                            | <B>bag &lt;</B>type<B>&gt;</B>
                            | <B>list &lt;</B>type<B>&gt;</B>
                            | <B>array &lt;</B>type<B>&gt;</B>
                            | <B>dictionary &lt;</B>type, type<B>&gt;</B>
                            | <B>identifier</B>

identifier              ::= letter{letter| digit| _}

literal                 ::= booleanLiteral
                            | longLiteral
                            | doubleLiteral
                            | charLiteral
                            | stringLiteral
                            | dateLiteral
                            | timeLiteral
                            | timestampLiteral
                            | <B>nil</B>
                            | <B>undefined</B>

booleanLiteral          ::= <B>true</B>
                            | <B>false</B>

longLiteral             ::= digit{digit}

doubleLiteral           ::= digit{digit}.digit{digit}
                            [(<B>E</B> | <B>e</B>)[<B>+</B>|<B>-</B>]digit{digit}]

charLiteral             ::= 'character'

stringLiteral           ::= "{character}"

dateLiteral             ::= <B>date</B>
                                'longliteral-longliteral-longliteral'

timeLiteral             ::= <B>time</B>
                                'longliteral:longLiteral:floatLiteral'

timestampLiteral        ::= <B>timestamp</B>
                                'longLiteral-longLiteral-longLiteral
                                longliteral:longLiteral:floatLiteral'

floatLiteral            ::= digit{digit}.digit{digit}

character               ::= letter
                            | digit
                            | special-character

letter                  ::= <B>A</B>|<B>B</B>|...|<B>Z</B>|
                            <B>a</B>|<B>b</B>|...|<B>z</B>

digit                   ::= <B>0</B>|<B>1</B>|...|<B>9</B>

special-character       ::= <B>?</B>|<B>_</B>|<B>*</B>|<B>%</B>|<B>\</B>
                </pre></span></span></p>

        <p><span class="bodyGrey">
            The following symbols were removed from the standard OQL Syntax for
            the following reasons:

            <table border="0" cellpadding="2" cellspacing="2"><tr><td colspan="2" height="5"></td></tr><span class="bodyGrey">
                <tr><td align="left" valign="top" width="10">-</td><td align="left" valign="top"><span class="bodyGrey">
                    <B>andthen</B>: Cannot be implemented in
                    a single SQL query. </span></td></tr>

                <tr><td align="left" valign="top" width="10">-</td><td align="left" valign="top"><span class="bodyGrey">
                    <B>orelse</B>: Same as above. </span></td></tr>

                <tr><td align="left" valign="top" width="10">-</td><td align="left" valign="top"><span class="bodyGrey">
                    <B>import</B>: This is advanced
                    functionality which may be added later. This phase will use the
                    castor mapping mechanism to define the namespace. </span></td></tr>

                <tr><td align="left" valign="top" width="10">-</td><td align="left" valign="top"><span class="bodyGrey">
                    Defined Queries: This is another feature
                    which can be added later. It is unclear where the queries would be
                    stored, and what their scope would be seeing as how this project
                    is an OQL to SQL translator, and not an ODBMS. </span></td></tr>

                <tr><td align="left" valign="top" width="10">-</td><td align="left" valign="top"><span class="bodyGrey">
                    iteratorDef was changed so that all
                    instances of expr were replaced by identifier. This means that the
                    from clause can only contain extent names (class names), rather
                    than any expression. This is the most common case and others could
                    create complicated SQL sub-queries or post-processing
                    requirements. </span></td></tr>
                <tr><td align="left" valign="top" width="10">-</td><td align="left" valign="top"><span class="bodyGrey">

                    objectConstruction and
                    structConstruction were removed. What is the scope of the
                    constructed object or struct, and how is a struct defined in Java? </span></td></tr>
                    </span></table></span></p>

        <p><span class="bodyGrey">
            The following symbols were added or modified.
            <table border="0" cellpadding="2" cellspacing="2"><tr><td colspan="2" height="5"></td></tr><span class="bodyGrey">
                <tr><td align="left" valign="top" width="10">-</td><td align="left" valign="top"><span class="bodyGrey">
                    <B>between</B> added to relationalExpr. </span></td></tr>

                <tr><td align="left" valign="top" width="10">-</td><td align="left" valign="top"><span class="bodyGrey">
                    Optional type specification added to
                    queryParam. </span></td></tr></span></table></span></p>
        <p><span class="bodyGrey">
            The rest of the standard OQL
            syntax remains unchanged. Certain syntactically correct queries may not
            be supported in Castor. For example, top level expressions which do not
            contain a selectExpr anywhere in the query may not be supported. This
            will be discussed further in the next section.</span></p>
    <a name="Type-and-validity-checking"><h2>Type and validity checking</h2></a>
        <p><span class="bodyGrey">
            The first pass over the ParseTree will do type checking, and create some
            structures used in the SQL generation pass. It will also check whether
            the identifiers used are valid, and whether the query uses unsupported
            features. The following table describes each type of node in the ParseTree, and
            how it will be processed in the first pass.</span></p>

        <p><span class="bodyGrey">
            <TABLE cellpadding="4" border="1">
              <TBODY>
              <TR>
                <TD>expr</TD>
                <TD>
                    <table border="0" cellpadding="2" cellspacing="2"><tr><td colspan="2" height="5"></td></tr><span class="bodyGrey"><tr><td align="left" valign="top" width="10">-</td><td align="left" valign="top"><span class="bodyGrey">
                            A query whose top level element is an expr, rather than a
                            selectExpr will not be supported within the scope of this project.
                            These queries can either be stated as a selectExpr, like
                            aggregateExpr's, or they would require post-processing of the SQL
                            results, like <B>element()</B><B>first()</B> and <B>last()</B>.</span></td></tr></span></table></TD>
                <TD>Phase 5</TD></TR>
              <TR>
                <TD>projectionAttributes</TD>
                <TD>
                    <table border="0" cellpadding="2" cellspacing="2"><tr><td colspan="2" height="5"></td></tr><span class="bodyGrey"><tr><td align="left" valign="top" width="10">-</td><td align="left" valign="top"><span class="bodyGrey">
                            select * will return a Collection of Arrays of Objects.</span></td></tr></span></table></TD>

                <TD>Phase 5</TD></TR>
              <TR>
                <TD>projectionList</TD>
                <TD>
                    <table border="0" cellpadding="2" cellspacing="2"><tr><td colspan="2" height="5"></td></tr><span class="bodyGrey">
                        <tr><td align="left" valign="top" width="10">-</td><td align="left" valign="top"><span class="bodyGrey">
                            Selecting multiple fields will
                            return a Collection of Arrays of Objects.</span></td></tr>

                        <tr><td align="left" valign="top" width="10">-</td><td align="left" valign="top"><span class="bodyGrey">
                            When there are multiple fields
                            selected, a list of field names and aliases will be kept for
                            checking validity of expr's in the whereClause, groupClause,
                            and orderClause.</span></td></tr>
                    </span></table></TD>
                <TD>Phase 5</TD></TR>
              <TR>
                <TD>projection</TD>
                <TD>
                    <table border="0" cellpadding="2" cellspacing="2"><tr><td colspan="2" height="5"></td></tr><span class="bodyGrey">
                        <tr><td align="left" valign="top" width="10">-</td><td align="left" valign="top"><span class="bodyGrey">
                            Alias identifier will be stored.</span></td></tr>

                        <tr><td align="left" valign="top" width="10">-</td><td align="left" valign="top"><span class="bodyGrey">
                            expr in projection may only be identifier, without an arglist.</span></td></tr>
                    </span></table></TD>
                <TD>Phase 1</TD></TR>
              <TR>
                <TD>projection</TD>
                <TD>
                    <table border="0" cellpadding="2" cellspacing="2"><tr><td colspan="2" height="5"></td></tr><span class="bodyGrey">
                        <tr><td align="left" valign="top" width="10">-</td><td align="left" valign="top"><span class="bodyGrey">
                            expr in projection may only be
                            identifier (with optional argList), aggregateExpr,
                            undefinedExpr, and postfixExpr (for selecting fields and
                            accessors).</span></td></tr>

                        <tr><td align="left" valign="top" width="10">-</td><td align="left" valign="top"><span class="bodyGrey">
                            The subquery in aggregateExpr and
                            undefinedExpr can be identifier (with optional arglist), or
                            postfixExpr for applying these functions to fields and
                            accessors.</span></td></tr>

                        <tr><td align="left" valign="top" width="10">-</td><td align="left" valign="top"><span class="bodyGrey">
                            If an identifier before the
                            <B>.</B> or <B>-&gt;</B> contains an arglist, it will be
                            considered a SQL function, and passed through to the
                            RDBMS.</span></td></tr>
                        <tr><td align="left" valign="top" width="10">-</td><td align="left" valign="top"><span class="bodyGrey">
                            If the postfixExpr contains one of
                            the above operators, the mapping mechanism will be used to
                            determine if the path expression is valid and to generate a
                            list of required join tables, using the manyKey and
                            manyTable from the JDOFieldDescriptor.</span></td></tr></span></table></TD>

                <TD>Phase 2</TD></TR>
              <TR>
                <TD>fromClause</TD>
                <TD>
                    <table border="0" cellpadding="2" cellspacing="2"><tr><td colspan="2" height="5"></td></tr><span class="bodyGrey"><tr><td align="left" valign="top" width="10">-</td><td align="left" valign="top"><span class="bodyGrey">
                            The class of the extent being selected from will be stored,
                            and ClassDescriptor objects will be instantiated.</span></td></tr></span></table></TD>
                <TD>Phase 1</TD></TR>
              <TR>
                <TD>whereClause</TD>
                <TD>
                    <table border="0" cellpadding="2" cellspacing="2"><tr><td colspan="2" height="5"></td></tr><span class="bodyGrey">
                        <tr><td align="left" valign="top" width="10">-</td><td align="left" valign="top"><span class="bodyGrey">
                            expr in whereClause may only
                            contain orExpr, andExpr, equalityExpr (without
                            compositePredicate), relationalExpr, additiveExpr (without
                            set operators <B>union</B> and <B>except</B>),
                            multiplicativeExpr (without set operator <B>intersect</B>),
                            unaryExpr, postFixExpr (must be only primaryExpr, no array
                            or property reference or method calls).</span></td></tr>

                        <tr><td align="left" valign="top" width="10">-</td><td align="left" valign="top"><span class="bodyGrey">
                            primaryExpr may only contain
                            identifier (without an argList), literal and queryParam.
                            Identifier will be checked against object name and alias in
                            projectionList.</span></td></tr>

                        <tr><td align="left" valign="top" width="10">-</td><td align="left" valign="top"><span class="bodyGrey">
                            For equalityExpr, relationalExpr,
                            aditiveExpr, multiplicativeExpr, the left side and right
                            side expr's must evaluate to comparable types.</span></td></tr>

                        <tr><td align="left" valign="top" width="10">-</td><td align="left" valign="top"><span class="bodyGrey">
                            For unaryExpr, simple type
                            checking for numerical or character based types will be
                            performed.</span></td></tr>

                        <tr><td align="left" valign="top" width="10">-</td><td align="left" valign="top"><span class="bodyGrey">

                            If the operands for any of the
                            relational, equality, additive, multiplicative, or unary
                            operators is a query parameter, an expected type will be
                            determined. If the parameter included a specified type which
                            is incompatible with the system determined type, an error
                            will be generated.</span></td></tr></span></table></TD>

                <TD>Phase 1</TD></TR>
              <TR>
                <TD>whereClause</TD>
                <TD>
                    <table border="0" cellpadding="2" cellspacing="2"><tr><td colspan="2" height="5"></td></tr><span class="bodyGrey">
                        <tr><td align="left" valign="top" width="10">-</td><td align="left" valign="top"><span class="bodyGrey">
                            Support for built in OQL functions
                            will be added to the whereClause: is_defined,
                            is_undefined.</span></td></tr>

                        <tr><td align="left" valign="top" width="10">-</td><td align="left" valign="top"><span class="bodyGrey">
                            inExpr will be supported in whereClause.</span></td></tr>

                        <tr><td align="left" valign="top" width="10">-</td><td align="left" valign="top"><span class="bodyGrey">
                            inExpr will only allow collectionConstruction for
                            the right side argument to <B>in</B>. No subQueries
                            will be allowed.</span></td></tr></span></table></TD>

                <TD>Phase 2</TD></TR>
              <TR>
                <TD>whereClause</TD>
                <TD>
                    <table border="0" cellpadding="2" cellspacing="2"><tr><td colspan="2" height="5"></td></tr><span class="bodyGrey">
                        <tr><td align="left" valign="top" width="10">-</td><td align="left" valign="top"><span class="bodyGrey">
                            identifiers will be able to
                            contain an optional arglist. If the arglist is before a
                            <B>.</B> or <B>-&gt;</B> the identifier will be considered a
                            SQL function and will be passed through to the DBMS.
                            Otherwise, the identifier will be for an accessor method, or
                            a property name.</span></td></tr>
                        <tr><td align="left" valign="top" width="10">-</td><td align="left" valign="top"><span class="bodyGrey">
                            Accessor methods and property
                            references will cause a check through the ClassDescriptor
                            and FieldDescriptors for the object type, and the required
                            join tables.</span></td></tr></span></table></TD>

                <TD>Phase 3</TD></TR>
              <TR>
                <TD>whereClause</TD>
                <TD>
                    <table border="0" cellpadding="2" cellspacing="2"><tr><td colspan="2" height="5"></td></tr><span class="bodyGrey">
                        <tr><td align="left" valign="top" width="10">-</td><td align="left" valign="top"><span class="bodyGrey">
                            compositePredicate will be
                            suported in equalityExpr.</span></td></tr>
                        <tr><td align="left" valign="top" width="10">-</td><td align="left" valign="top"><span class="bodyGrey">
                            exists(query) will be supported.</span></td></tr>

                        <tr><td align="left" valign="top" width="10">-</td><td align="left" valign="top"><span class="bodyGrey">
                            quantifierExpr will support <B>for
                            all</B> and <B>exists</B>.</span></td></tr>

                        <tr><td align="left" valign="top" width="10">-</td><td align="left" valign="top"><span class="bodyGrey">
                            Subqueries will be supported on the right side of
                            the <B>in</B> operator</span></td></tr></span></table></TD>

                <TD>Phase 4</TD></TR>
              <TR>
                <TD>groupClause, havingClause</TD>
                <TD>
                    <table border="0" cellpadding="2" cellspacing="2"><tr><td colspan="2" height="5"></td></tr><span class="bodyGrey">
                        <tr><td align="left" valign="top" width="10">-</td><td align="left" valign="top"><span class="bodyGrey">
                            Will identify appropriate fields
                            in SQL schema for each expr.</span></td></tr>

                        <tr><td align="left" valign="top" width="10">-</td><td align="left" valign="top"><span class="bodyGrey">
                            aggregateExpr will be supported.</span></td></tr>

                        <tr><td align="left" valign="top" width="10">-</td><td align="left" valign="top"><span class="bodyGrey">
                            Only expr's which translate to SQL
                            columns whcih are already being selected will be
                            supported.</span></td></tr></span></table></TD>

                <TD>Phase 4</TD></TR>
              <TR>
                <TD>orderClause</TD>
                <TD>
                        <table border="0" cellpadding="2" cellspacing="2"><tr><td colspan="2" height="5"></td></tr><span class="bodyGrey"><tr><td align="left" valign="top" width="10">-</td><td align="left" valign="top"><span class="bodyGrey">
                            May only contain expr's which translate into SQL columns which
                            are already being selected.</span></td></tr></span></table></TD>
                <TD>Phase 3</TD></TR></TBODY></TABLE></span></p>
    <a name="SQL-Generation"><h2>SQL Generation</h2></a>
        <p><span class="bodyGrey">
            After the first pass, the ParseTree is free of errors, and ready for
            the SQL generation step. The existing implementation of the OQLParser
            uses the persistence API for SQL generation. This API lacks the
            necessary features to generate SQL from any OQL. The SQLEngine class
            which implements Persistence is used to create a JDBCQueryExpression.
            The SQL is derived from the finder, which is a JDBCQueryExpression
            produced by the SQLEngine. The problem is that the SQLEngine only
            supports single objects. It cannot generate SQL for path expressions
            like this:
            <span class="bodyBlack"><pre>
select p.address from Person p </pre></span>

            This query requires a SQL statement like this:
            <span class="bodyBlack"><pre>
select address.* from person, address
    where person.address_id = address.address_id</pre></span></span></p>

        <p><span class="bodyGrey">
            The buildFinder method should not be used to generate a
            queryExpression. The SQLEngine should be used to get a ClassDescriptor,
            and to create a new QueryExpression. The OQLParser should use the
            methods in the QueryExpression to generate the SQL. The
            JDBCQueryExpression which is an implementation of QueryExpression is
            also lacking in necessary features. This class should continue to be
            used, but the following features will need to be added:
            <DL>
              <DT>addColumn(String)</DT>
              <DD>For adding something to select without specifying the tablename,
              for use with functions (i.e. select count(*))</DD>
              <DT>addTable(String)</DT>
              <DD>For when the table has to be added manually.</DD>
              <DT>addCondition(String)</DT>
              <DD>Add a condition created outside the class, for nested expressions,
              and other expressions that are not of the form table.column op
              table.column.</DD>
              <DT>setDistinct(boolean)</DT>
              <DD>Used for select distinct.</DD>
              <DT>addOrderColumn(String tableName, String columnName, boolean desc)</DT>
              <DD>Used for order by</DD>
              <DT>addGroupExpr(String)</DT>
              <DD>Used for group by</DD>
              <DT>addHavingExpr(String)</DT>
              <DD>Used for having.</DD></DL></span></p>

        <p><span class="bodyGrey">
            The following table lists each type of
            tree node, and how it will be processed in the SQL generation pass.</span></p>

        <p><span class="bodyGrey">
            <TABLE cellpadding="4" border="1">
              <TBODY>
              <TR>
                <TD>selectExpr</TD>
                <TD>
                    <table border="0" cellpadding="2" cellspacing="2"><tr><td colspan="2" height="5"></td></tr><span class="bodyGrey"><tr><td align="left" valign="top" width="10">-</td><td align="left" valign="top"><span class="bodyGrey">
                        distinct in the selectExpr will result in a call to
                        setDistinct(true) in the queryExpr.</span></td></tr></span></table></TD>
                <TD>Phase 2</TD></TR>
              <TR>
                <TD>projection</TD>
                <TD>
                    <table border="0" cellpadding="2" cellspacing="2"><tr><td colspan="2" height="5"></td></tr><span class="bodyGrey"><tr><td align="left" valign="top" width="10">-</td><td align="left" valign="top"><span class="bodyGrey">
                        The queryExpr will be populated with the columns and tables
                        necessary to retrieve the object. This will use code similar to
                        SQLEngine.addLoadSql(...). </span></td></tr></span></table></TD>
                <TD>Phase 1</TD></TR>
              <TR>
                <TD>projection</TD>
                <TD>
                    <table border="0" cellpadding="2" cellspacing="2"><tr><td colspan="2" height="5"></td></tr><span class="bodyGrey">
                        <tr><td align="left" valign="top" width="10">-</td><td align="left" valign="top"><span class="bodyGrey">
                            aggregateExpr and SQL functions
                            will be passed to addColumn.</span></td></tr>

                        <tr><td align="left" valign="top" width="10">-</td><td align="left" valign="top"><span class="bodyGrey">
                            undefinedExpr will be translated
                            to <B>is null</B> and <B>is not null</B></span></td></tr>

                        <tr><td align="left" valign="top" width="10">-</td><td align="left" valign="top"><span class="bodyGrey">
                            postfixExpr (for selecting fields
                            and accessors) will result in a different group of select
                            expressions and "from tables" being
                            generated.</span></td></tr></span></table></TD>

                <TD>Phase 2</TD></TR>
              <TR>
                <TD>whereClause</TD>
                <TD>
                    <table border="0" cellpadding="2" cellspacing="2"><tr><td colspan="2" height="5"></td></tr><span class="bodyGrey">
                        <tr><td align="left" valign="top" width="10">-</td><td align="left" valign="top"><span class="bodyGrey">
                            Entire expr in where clause will be translated, and then added
                            to the QueryExpr, using a single call to addCondition(String), and
                            multiple calls to addTable(String).</span></td></tr></span></table></TD>
                <TD>Phase 1</TD></TR>
              <TR>
                <TD>whereClause</TD>
                <TD>
                    <table border="0" cellpadding="2" cellspacing="2"><tr><td colspan="2" height="5"></td></tr><span class="bodyGrey">
                        <tr><td align="left" valign="top" width="10">-</td><td align="left" valign="top"><span class="bodyGrey">
                            <B>is_defined()</B> will translate
                            into <B>is not null</B> and <B>is_undefined()</B> will
                            translate into <B>is null</B>.</span></td></tr>

                        <tr><td align="left" valign="top" width="10">-</td><td align="left" valign="top"><span class="bodyGrey">
                            inExpr will translate directly,
                            with the collectionConstruction
                            removed.</span></td></tr></span></table></TD>

                <TD>Phase 2</TD></TR>
              <TR>
                <TD>whereClause</TD>
                <TD>
                    <table border="0" cellpadding="2" cellspacing="2"><tr><td colspan="2" height="5"></td></tr><span class="bodyGrey">
                        <tr><td align="left" valign="top" width="10">-</td><td align="left" valign="top"><span class="bodyGrey">
                            compositePredicate and
                            exists(query) translate directly to SQL.</span></td></tr>
                        <tr><td align="left" valign="top" width="10">-</td><td align="left" valign="top"><span class="bodyGrey">
                            For quantifierExpr, <B>exists</B>
                            will translate into an exists() SQL subquery. <B>for all</B>
                            will translate into the contrapositive(?) exists query, for
                            example:

                            <span class="bodyBlack"><pre>
for all x in teachers:
    x.name = 'Nis'</pre></span>
                            translates to:
                            <span class="bodyBlack"><pre>
not exists (select * from teachers
    where name != 'Nis')</pre></span>
                            </span></td></tr></span></table></TD>

                <TD>Phase 4</TD></TR></TBODY></TABLE></span></p>
    <a name="OQL-FAQ"><h2>OQL FAQ</h2></a>
        <p><span class="bodyGrey">
            Please see the <a href="jdo-faq.html#OQL">OQL section</a> of the JDO FAQ.
        </span></p>
    <a name="Summary"><h2>Summary</h2></a>
        <p><span class="bodyGrey">
            The Parser and ParseTree classes will be improved through the phases
            of this project. The top level of OQL to SQL translation will look very
            simple, like this:
            <span class="bodyBlack"><pre>
OQLParser parser = new OQLParser(query);
ParseTree pt = parser.getParseTree();
pt.checkPass();
<span class="bodyGrey"><font color="red">//the SQL generation pass</font></span>
_expr = pt.getQueryExpr();
            </pre></span>

            These methods will have some additional parameters passed
            for storing and retrieving data relevant to the query. Following is a
            table containing a list of what will be introduced in each coding phase
            of the project.</span></p>

        <p><span class="bodyGrey">
                <TABLE cellpadding="4" border="1">
                  <TBODY>
                  <TR>
                    <TD>Phase 1</TD>
                    <TD>
                        <table border="0" cellpadding="2" cellspacing="2"><tr><td colspan="2" height="5"></td></tr><span class="bodyGrey">
                            <tr><td align="left" valign="top" width="10">-</td><td align="left" valign="top"><span class="bodyGrey">
                                New parser structure which
                                generates symbol tree</span></td></tr>

                            <tr><td align="left" valign="top" width="10">-</td><td align="left" valign="top"><span class="bodyGrey">
                                Parser still supports only limited OQL</span></td></tr>

                            <tr><td align="left" valign="top" width="10">-</td><td align="left" valign="top"><span class="bodyGrey">
                                selected field aliases</span></td></tr>

                            <tr><td align="left" valign="top" width="10">-</td><td align="left" valign="top"><span class="bodyGrey">
                                whereClause supports or, and,
                                equality, additive, multiplicative, and unary
                                Operators.</span></td></tr>

                            <tr><td align="left" valign="top" width="10">-</td><td align="left" valign="top"><span class="bodyGrey">
                                support for specifying parameter types</span></td></tr>

                            <tr><td align="left" valign="top" width="10">-</td><td align="left" valign="top"><span class="bodyGrey">
                                check specified parameter type
                                against system determined type</span></td></tr>

                            <tr><td align="left" valign="top" width="10">-</td><td align="left" valign="top"><span class="bodyGrey">
                                specifying ordered parameters.</span></td></tr>

                            <tr><td align="left" valign="top" width="10">-</td><td align="left" valign="top"><span class="bodyGrey">
                                JDBCQueryExpression must support
                                addCondition(String condition)</span></td></tr></span></table></TD></TR>

                  <TR>
                    <TD>Phase 2</TD>
                    <TD>
                        <table border="0" cellpadding="2" cellspacing="2"><tr><td colspan="2" height="5"></td></tr><span class="bodyGrey">
                            <tr><td align="left" valign="top" width="10">-</td><td align="left" valign="top"><span class="bodyGrey">
                                Distinct keyword will be supported
                                in selectExpr</span></td></tr>

                            <tr><td align="left" valign="top" width="10">-</td><td align="left" valign="top"><span class="bodyGrey">
                                aggregateExpr and undefinedExpr
                                supported in projection (Select statement)</span></td></tr>

                            <tr><td align="left" valign="top" width="10">-</td><td align="left" valign="top"><span class="bodyGrey">
                                isDefined, isUndefined in whereClause</span></td></tr>

                            <tr><td align="left" valign="top" width="10">-</td><td align="left" valign="top"><span class="bodyGrey">
                                inExpr in whereClause</span></td></tr>

                            <tr><td align="left" valign="top" width="10">-</td><td align="left" valign="top"><span class="bodyGrey">
                                type checking/conversion in bind()</span></td></tr>

                            <tr><td align="left" valign="top" width="10">-</td><td align="left" valign="top"><span class="bodyGrey">
                                fields and accessors in the
                                projection. Mapping mechanism may need some additional
                                features.</span></td></tr>

                            <tr><td align="left" valign="top" width="10">-</td><td align="left" valign="top"><span class="bodyGrey">
                                SQL functions in the projection</span></td></tr>

                            <tr><td align="left" valign="top" width="10">-</td><td align="left" valign="top"><span class="bodyGrey">
                                order by</span></td></tr></span></table></TD></TR>
                  <TR>
                    <TD>Phase 3</TD>
                    <TD>
                        <table border="0" cellpadding="2" cellspacing="2"><tr><td colspan="2" height="5"></td></tr><span class="bodyGrey">
                            <tr><td align="left" valign="top" width="10">-</td><td align="left" valign="top"><span class="bodyGrey">
                                fields and accessors in whereClause</span></td></tr>

                            <tr><td align="left" valign="top" width="10">-</td><td align="left" valign="top"><span class="bodyGrey">
                                SQL functions in the where clause</span></td></tr></span></table></TD></TR>

                  <TR>
                    <TD>Phase 4</TD>
                    <TD>
                        <table border="0" cellpadding="2" cellspacing="2"><tr><td colspan="2" height="5"></td></tr><span class="bodyGrey">
                            <tr><td align="left" valign="top" width="10">-</td><td align="left" valign="top"><span class="bodyGrey">
                                sub queries</span></td></tr>

                            <tr><td align="left" valign="top" width="10">-</td><td align="left" valign="top"><span class="bodyGrey">
                                exists()</span></td></tr>

                            <tr><td align="left" valign="top" width="10">-</td><td align="left" valign="top"><span class="bodyGrey">
                                compositePredicate</span></td></tr>

                            <tr><td align="left" valign="top" width="10">-</td><td align="left" valign="top"><span class="bodyGrey">
                                quantifierExpr's: for all and exists</span></td></tr>

                            <tr><td align="left" valign="top" width="10">-</td><td align="left" valign="top"><span class="bodyGrey">
                                group by</span></td></tr>

                            <tr><td align="left" valign="top" width="10">-</td><td align="left" valign="top"><span class="bodyGrey">
                                having</span></td></tr></span></table></TD></TR>

                  <TR>
                    <TD>Phase 5:</TD>
                    <TD>
                        <table border="0" cellpadding="2" cellspacing="2"><tr><td colspan="2" height="5"></td></tr><span class="bodyGrey">
                            <tr><td align="left" valign="top" width="10">-</td><td align="left" valign="top"><span class="bodyGrey">
                                expr as top level symbol</span></td></tr>

                            <tr><td align="left" valign="top" width="10">-</td><td align="left" valign="top"><span class="bodyGrey">
                                queries selecting multiple fields or as
                                comma separated list or * </span></td></tr></span></table></TD></TR>
            </TBODY></TABLE></span></p>
        <a name="Examples"><h2>Examples</h2></a>

       <p><span class="bodyGrey">Please find below various examples of OQL queries using the Java class files 
          as outlined below.</span></p>

       <a name="Java-class-files"><h3>Java class files</h3></a>
       
          <p><span class="bodyGrey">The following fragment shows the Java class declaration for the Product class:</span></p>
       
          <table border="1" cellpadding="4">
             <tr>
                <td BGCOLOR="#CCCCCC"><span class="bodyGrey" BGCOLOR="#CCCCCC">
                   <span class="bodyBlack"><pre>
package myapp;

public class Product 
{
    private int       _id;

    private String    _name; 

    private float     _price; 

    private ProductGroup _group;


    public int getId() { ... }

    public void setId( int anId ) { ... }

    public String getName() { ... }

    public void setName( String aName ) { ... }

    public float getPrice() { ... }

    public void setPrice( float aPrice ) { ... }

    public ProductGroup getProductGroup() { ... }

    public void setProductGroup( ProductGroup aProductGroup ) { ... }
}
               </pre></span>
            </span></td>
         </tr>
      </table>

      <p><span class="bodyGrey">The following fragment shows the Java class declaration for the ProductGroup class:</span></p>
      
      <table border="1" cellpadding="4">
              <tr>
                <td BGCOLOR="#CCCCCC"><span class="bodyGrey" BGCOLOR="#CCCCCC">
                    <span class="bodyBlack"><pre>


public class ProductGroup
{

    private int       _id;

    private String    _name;

    public int getId() { ... }

    public void setId( int id ) { ... }

    public String getName() { ... }

    public void setName( String name ) { ... }

}
                  </pre></span>
               </span></td>
            </tr>
         </table>
      
      
      <a name="Limit-Clause"><h3>Limit Clause</h3></a>
      
         <p><span class="bodyGrey">On a selected number of RDBMS, Castor JDO now supports the use of LIMIT/OFFSET
			clauses.</span></p>
			
         <p><span class="bodyGrey">As per this release, the following RDBMS have full/partial support for this
            feature.</span></p>

                <table border="0" cellspacing="1" cellpadding="2" bgcolor="#990033"><tr><td><span class="bodyGrey">
                    <table border="0" cellspacing="1" cellpadding="8" bgcolor="#EDEDED">
                  <tr bgcolor="#990033" style="color:#FFFFFF">
                            <th align="left">RDBMS</th><th>LIMIT</th><th>OFFSET</th>
                        </tr><tr>
                            <td><span class="bodyGrey">postgreSQL</span></td><td><span class="bodyGrey">Yes</span></td><td><span class="bodyGrey">Yes</span></td>
                        </tr><tr>
                            <td><span class="bodyGrey">mySQL</span></td><td><span class="bodyGrey">Yes</span></td><td><span class="bodyGrey">Yes</span></td>
                        </tr><tr>
                            <td><span class="bodyGrey">Oracle - 1)2)</span></td><td><span class="bodyGrey">Yes</span></td><td><span class="bodyGrey">Yes</span></td>
                        </tr><tr>
                            <td><span class="bodyGrey">HSQL</span></td><td><span class="bodyGrey">Yes</span></td><td><span class="bodyGrey">Yes</span></td>
                        </tr><tr>
                            <td><span class="bodyGrey">MS SQL</span></td><td><span class="bodyGrey">Yes</span></td><td><span class="bodyGrey">-</span></td>
                        </tr><tr>
                            <td><span class="bodyGrey">DB2</span></td><td><span class="bodyGrey">Yes</span></td><td><span class="bodyGrey">-</span></td>
                        </tr>
                    </table></span></td></tr>
                </table>

         <p><span class="bodyGrey">1) Oracle has full support for LIMIT/OFFSET clauses for release 8.1.6 and
            later.</span></p>
         <p><span class="bodyGrey">2) For the LIMIT/OFFSET clauses to work properly the OQL query is required
			to include a ORDER BY clause.</span></p>

         <p><span class="bodyGrey">The following code fragment shows an OQL query that uses the LIMIT keyword 
            to select the first 10 ProductGroup instances.</span></p>
      
         <table border="1" cellpadding="4">
            <tr>
               <td BGCOLOR="#CCCCCC"><span class="bodyGrey" BGCOLOR="#CCCCCC">
                  <span class="bodyBlack"><pre>
query = db.getOQLQuery("select p from ProductGroup as p <b><font color="red">LIMIT $1</font></b>");
query.bind(10);
                  </pre></span>
               </span></td>
            </tr>
         </table>
         
         <p><span class="bodyGrey">Below is the same OQL query again, restricting the number of ProductGroup instances
            returned to 10, though this time it is specified that the ProductGroup 
            instances 11 to 20 should be returned.</span></p>

         <table border="1" cellpadding="4">
            <tr>
               <td BGCOLOR="#CCCCCC"><span class="bodyGrey" BGCOLOR="#CCCCCC">
                  <span class="bodyBlack"><pre>
query = db.getOQLQuery ("select p from ProductGroup as p <b>LIMIT $1 <font color="red">OFFSET $2</font></b>");
query.bind(10);
                  </pre></span>
               </span></td>
            </tr>
         </table>
         
         <p><span class="bodyGrey">In the case a RDBMS does not support LIMIT/OFFSET clauses, a  SyntaxNotSupportedException 
            will be thrown.</span></p>
      
      
    </td></tr><tr height="5"><td width="10" height="5" bgcolor="#7270c2" valign="top" align="left">&nbsp;</td><td height="5" bgcolor="#7270c2" valign="top" width="150"><img src="images/dotTrans.gif" width="1" height="15" border="0"><br><img src="images/line_sm.gif" width="105" height="3" border="0" align="right"></td><td width="7" height="5" bgcolor="#a9a5de" valign="top" align="left">&nbsp;</td><td width="70" height="5" valign="top" align="left">&nbsp;</td><td width="120" height="5" valign="top" align="left">&nbsp;</td></tr><tr><td width="10" height="5" bgcolor="#7270c2" valign="top" align="left">&nbsp;</td><td bgcolor="#7270c2" valign="top" align="left" width="150"></td><td width="7" bgcolor="#a9a5de" valign="top" align="left"><img src="images/dotTrans.gif" width="1" height="25" border="0"></td><td width="70" valign="top" align="left"><img src="images/dotTrans.gif" width="1" height="25" border="0"></td><td width="120" valign="top" align="left">&nbsp;</td></tr><tr height="5"><td width="10" rowspan="2" height="100%" bgcolor="#7270c2" valign="bottom" align="left"><img src="images/stripes1.gif" width="10" height="125" border="0"></td><td rowspan="2" height="100%" bgcolor="#7270c2" valign="bottom" align="left" width="150"><img src="images/stripe105.gif" width="105" height="125" border="0"></td><td width="7" rowspan="2" height="100%" bgcolor="#a9a5de" valign="top" align="left">&nbsp;</td><td width="70" height="100%" valign="top" align="left">&nbsp;</td><td width="120" height="100%" valign="top" align="left">&nbsp;</td></tr><tr height="5"><td width="70" height="25" valign="top" align="left">&nbsp;</td><td width="400" height="25" valign="bottom" align="left"><br><br><img src="images/line_light.gif" border="0" width="400" height="3"><br><p></p><span class="bodyGrey"><small><notice>
    Copyright &copy; 1999-2005 <a href="http://www.exolab.org">ExoLab Group</a>, Intalio Inc.,
    and Contributors.  All rights reserved.
  </notice><br>&nbsp;<br></small><small><notice>
    Java, EJB, JDBC, JNDI, JTA, Sun, Sun Microsystems are trademarks or registered
    trademarks of Sun Microsystems, Inc. in the United States and in other
    countries. XML, XML Schema, XSLT and related standards are trademarks or registered
    trademarks of MIT, INRIA, Keio or others, and a product of the World Wide Web
    Consortium. All other product names mentioned herein are trademarks of their respective
    owners.
  </notice><br>&nbsp;<br></small></span><p></p>
          &nbsp;
        </td><td width="120" height="25" valign="top" align="left">&nbsp;</td></tr></table><script type="text/javascript">
        var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
        document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
    </script><script type="text/javascript">
        var pageTracker = _gat._getTracker("UA-3544187-1");
        pageTracker._trackPageview();
    </script></body></html>